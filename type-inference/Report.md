# Exercise 4.1(必修課題)
syntax.mlに型推論のための型を定義し、main.mlでは処理を実行する前に型推論を行うようにeval_declの前にty_declを追加する。  
typing.mlではty_primでプリミティブ型の処理の型推論を行う、規則は資料通りに行う、２つの引数から判定し、もし規則通りでなければエラーを返す。  
ty_expでは型推論用の環境変数を受け取って、推論する型によって処理を分ける。IfExpでは条件式がBoolである必要があり、またthen節とelse節の推論結果から型が正しいか判定するように実装し、値によってエラーの内容を変えた。  
LetExpはexp1の型推論結果をidに紐付けて、環境を拡張し、exp2の型推論結果を返す。  

```
$ ./miniml
# if true then 1 else 2;;
val - : int = 1
# let a = 3 in a + 4;;
val - : int = 7
```

# Exercise 4.2(必修課題)
関数pp_tyは、tyの型のパターンマッチで表示する文字列を場合分けした。  
TyVarの場合現状すべての型を\`aと表示するようになっている。  
関数freevar_tyは、再帰的に型変数TyVarをパターンマッチで抽出していく。  
# Exercise 4.3(必修課題)
substの先頭を取り出して型代入を実行し、それをリストの末尾まで再帰的に繰り返す。  
型代入は、代入される型がTyVarであり代入する型変数と変数名が一致していた場合のみ取り替える、TyFunであれば２つの型に対して再帰的に代入を繰り返す。
# Exercise 4.4(必修課題)
資料にある定義通りに実装した。  
パターンマッチで、次の通りに場合分けした。  

1. 2つの型がどちらもTyIntもしくはTyBoolの場合、  
	末尾のリストを単一化する
2. 2つの型がどちらも型変数の場合、  
	もし型変数が同じなら末尾のリストを単一化する。  
	そうでなければ１つ目の型変数に２つ目の型変数を割り当てて、その型を末尾の型リストに型代入して再帰的に実行する。
3. 2つの型のどちらかが型変数vの場合、  
	型変数でない方の型変数リストに型変数vが含まれている場合は型エラー  
	そうでなければ型変数vにもう一方の型を割り当てて、その型を末尾の型リストに代入して再帰的に実行する。
4. ２つの型がどちらもTyFunの場合、  
	左辺と右辺同士をタプルにした型をリストにつなげて再帰的に実行する。
5. それ以外の場合、  
	型エラー

# Exercise 4.5(必修課題)
例えば、 `(TyVar 'a', TyFun (TyBool, TyVar 'a'))` について考えた時、'a'にどのような型を割り当てたとしても２つの式が一致することはないため。
# Exercise 4.6(必修課題)
### T-VAR
型代入はなしで、型環境から探索してきた型を返す。

### T-INT
型代入はなしで、TyIntを返す。

### T-BOOL
型代入はなしで、TyBoolを返す。

### T-PLUS (e1 + e2)
1. Γ, e1 を入力として型推論を行い，S1, τ1 を得る．
2. Γ, e2 を入力として型推論を行い，S2, τ2 を得る．
3. 型代入 S1, S2 を α = τ という形の方程式の集まりとみなして，S1∪S2∪{(τ1, int),(τ2, int)}
を単一化し，型代入 S3 を得る．
4. S3 と int を出力として返す．

### T-MULT (e1 * e2)
1. Γ, e1 を入力として型推論を行い，S1, τ1 を得る．
2. Γ, e2 を入力として型推論を行い，S2, τ2 を得る．
3. 型代入 S1, S2 を α = τ という形の方程式の集まりとみなして，S1∪S2∪{(τ1, int),(τ2, int)}
を単一化し，型代入 S3 を得る．
4. S3 と int を出力として返す．

### T-LT (e1 < e2)
1. Γ, e1 を入力として型推論を行い，S1, τ1 を得る．
2. Γ, e2 を入力として型推論を行い，S2, τ2 を得る．
3. 型代入 S1, S2 を α = τ という形の方程式の集まりとみなして，S1∪S2∪{(τ1, int),(τ2, int)}
を単一化し，型代入 S3 を得る．
4. S3 と bool を出力として返す．

### T-IF (if e1 then e2 else e3)
1. Γ, e1 を入力として型推論を行い，Scond, τcond を得る．
2. Γ, e2 を入力として型推論を行い，S1, τ1 を得る．
3. Γ, e3 を入力として型推論を行い，S2, τ2 を得る．
4. 型代入 Scond, S1, S2 を α = τ という形の方程式の集まりとみなして，Scond∪S1∪S2∪{(τcond, bool), (τ1, τ2)}
を単一化し，型代入 S3 を得る．
5. S3 と τ1 (or τ2) を出力として返す．

### T-LET (let id = e1 in e2)
1. Γ, e1 を入力として型推論を行い，S1, τ1 を得る．
2. Γ(id : τ1), e2 を入力として型推論を行い，S2, τ2 を得る.
3. 
4. 型代入 Scond, S1, S2 を α = τ という形の方程式の集まりとみなして，Scond∪S1∪S2∪{(τcond, bool), (τ1, τ2)}
を単一化し，型代入 S3 を得る．
5. S3 と τ1 (or τ2) を出力として返す．
